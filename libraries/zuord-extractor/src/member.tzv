import { BindingName, Node, TypeNode } from "ts-morph";
import { node as znode } from "./node";
import { MemberType } from "./member";

export const isUnknown = (member: ZSchema.Base): member is ZSchema.Unknown => {
    return member.type === MemberType.Unknown;
}

export const isImport = (member: ZSchema.Base): member is ZSchema.Import => {
    return member.type === MemberType.Import;
}

export const isExport = (member: ZSchema.Base): member is ZSchema.Export => {
    return member.type === MemberType.Export;
}

export const isExportDefault = (member: ZSchema.Base): member is ZSchema.ExportDefault => {
    return member.type === MemberType.ExportDefault;
}

export const isType = (member: ZSchema.Base): member is ZSchema.Type => {
    return member.type === MemberType.Type;
}

export const isInterface = (member: ZSchema.Base): member is ZSchema.Interface => {
    return member.type === MemberType.Interface;
}

export const isVariable = (member: ZSchema.Base): member is ZSchema.Variable => {
    return member.type === MemberType.Variable;
}

export const isFunction = (member: ZSchema.Base): member is ZSchema.Function => {
    return member.type === MemberType.Function;
}

export const isValue = (member: ZSchema.Base): member is ZSchema.Value => {
    return member.type === MemberType.Value;
}

export const isArrowFunction = (member: ZSchema.Base): member is ZSchema.ArrowFunction => {
    return member.type === MemberType.ArrowFunction;
}

export const isFunctionExpression = (member: ZSchema.Base): member is ZSchema.FunctionExpression => {
    return member.type === MemberType.FunctionExpression;
}

//

export const isKnownLike = (member: ZSchema.Base): member is ZSchema.KnownLike => {
    return isESMLike(member) || isSchemaLike(member) || isVariantLike(member);
}

export const isGlobalLike = (member: ZSchema.Base): member is ZSchema.GlobalLike => {
    return isESMLike(member);
}

export const isESMLike = (member: ZSchema.Base): member is ZSchema.ESMLike => {
    return isExport(member) || isImport(member) || isExportDefault(member);
}

export const isDefinitionLike = (member: ZSchema.Base): member is ZSchema.DefinitionLike => {
    return isESMLike(member) || isDefinitionOnly(member);
}

export const isDefinitionOnly = (member: ZSchema.Base): member is ZSchema.DefinitionOnly => {
    return isSchemaOnly(member) || isVariantOnly(member);
}

export const isSchemaLike = (member: ZSchema.Base): member is ZSchema.SchemaLike => {
    return isESMLike(member) || isSchemaOnly(member);
}

export const isSchemaOnly = (member: ZSchema.Base): member is ZSchema.SchemaOnly => {
    return isType(member) || isInterface(member);
}

export const isVariantLike = (member: ZSchema.Base): member is ZSchema.VariantLike => {
    return isESMLike(member) || isVariantOnly(member);
}

export const isVariantOnly = (member: ZSchema.Base): member is ZSchema.VariantOnly => {
    return isVariable(member) || isFunction(member);
}

export const isInitializerLike = (member: ZSchema.Base): member is ZSchema.InitializerLike => {
    return isArrowFunction(member) || isFunctionExpression(member) || isValue(member);
}

export const isValueVariable = (member: ZSchema.Base): member is ZSchema.ValueVariable => {
    return isVariable(member) && !!member.initializer && isValue(member.initializer);
}

export const isFunctionalVariable = (member: ZSchema.Base): member is ZSchema.FunctionalVariable => {
    return isVariable(member) && !!member.initializer && isFunctionAlt(member.initializer);
}

export const isFunctionLike = (member: ZSchema.Base): member is ZSchema.FunctionLike => {
    return isFunction(member) || isFunctionExpression(member) || isArrowFunction(member);
}

export const isFunctionAlt = (member: ZSchema.Base): member is ZSchema.FunctionAlt => {
    return isArrowFunction(member) || isFunctionExpression(member);
}

//

export  const isFunctionalVariant = (member: ZSchema.Base): member is ZSchema.FunctionalVariant => {
    return isFunction(member) || isFunctionalVariable(member);
};

//

export const create = <TMember extends ZSchema.Base>(
    node: Node
) : TMember => {

    const member = {
        node,
        type: getKind(node)
    } as TMember;

    if(isVariable(member)) {
        updateInitializer(member);
    }

    return member;
}

export const getKind = (node: Node): MemberType => {
    if (znode.isImport(node)) {
        return MemberType.Import;
    }

    if (znode.isExport(node)) {
        return MemberType.Export;
    }

    if (znode.isExportDefault(node)) {
        return MemberType.ExportDefault;
    }

    if (znode.isType(node)) {
        return MemberType.Type;
    }

    if (znode.isInterface(node)) {
        return MemberType.Interface;
    }

    if (znode.isVariable(node)) {
        return MemberType.Variable;
    }

    if (znode.isValue(node)) {
        return MemberType.Value;
    }

    if (znode.isFunction(node)) {
        return MemberType.Function;
    }

    if (znode.isArrowFunction(node)) {
        return MemberType.ArrowFunction;
    }

    if (znode.isFunctionExpression(node)) {
        return MemberType.FunctionExpression;
    }

    return MemberType.Unknown;
};

export const getNameNode = (member: ZSchema.DefinitionLike): BindingName | null => {
    if("getNameNode" in member.node) {
        return member.node.getNameNode() ?? null;
    }

    if(isVariable(member)) {
        const declaration = member.node.getDeclarations()[0];

        if(declaration) {
            return declaration.getNameNode() ?? null;
        }
    }

    return null;
}

export const getInitializer = (member: ZSchema.Variable): ZSchema.InitializerLike | undefined => {
    if(!member) return undefined;

    const declaration = member.node.getDeclarations()[0];

    if(declaration) {
        const initializerNode = declaration.getInitializer();

        if(initializerNode) {
            if(znode.isInitializerLike(initializerNode)) {
                return create<ZSchema.InitializerLike>(initializerNode);
            }
        }
    }

    return undefined
}

export const getDeclaredType = (member: ZSchema.ValueVariable): TypeNode | undefined => {
    return member?.node?.getDeclarations()[0]?.getTypeNode();
}

export const getReturnType = (member: ZSchema.FunctionLike): TypeNode | undefined => {
    return member?.node?.getReturnTypeNode();
}

export const getFunctionalVariantReturnType = (member: ZSchema.FunctionalVariant) : TypeNode | undefined => {
    return getReturnType(asFunctionLike(member)!);
}

export const getFunctionalVariantParamType = (member: ZSchema.FunctionalVariant) : TypeNode | undefined => {
    return getParamType(asFunctionLike(member)!);
}

export const getParamType = (member: ZSchema.FunctionLike): TypeNode | undefined => {
    return member?.node?.getParameters()[0]?.getTypeNode();
}

export const asFunctionLike = (member: ZSchema.FunctionalVariant) : ZSchema.FunctionLike | undefined => {
    if(isFunctionalVariable(member)) {
        return member.initializer!;
    }

    return member;
}

//

export const updateNameNode = (member: ZSchema.DefinitionLike): void => {
    if(member.nameNode == undefined) {
        member.nameNode = getNameNode(member);
    }
}

export const updateInitializer = (member: ZSchema.Variable): void => {
    if(member.initializer == undefined) {
        member.initializer = getInitializer(member);
    }
}

export const updateDeclaredType = (member: ZSchema.ValueVariable): void => {
    if(member.declaredTypeNode == undefined) {
        member.declaredTypeNode = getDeclaredType(member);
    }
}

export const updateReturnType = (member: ZSchema.FunctionLike): void => {
    if(member.returnTypeNode == undefined) {
        member.returnTypeNode = getReturnType(member);
    }
};

export const updateParamType = (member: ZSchema.FunctionLike): void => {
    if(member.paramTypeNode == undefined) {
        member.paramTypeNode = getParamType(member);
    }
};

export const updateFunctionalReturnTypeNode = (member: ZSchema.FunctionalVariant): void => {
    return updateReturnType(asFunctionLike(member)!);
};

export const updateFunctionalParamTypeNode = (member: ZSchema.FunctionalVariant): void => {
    return updateParamType(asFunctionLike(member)!);
};